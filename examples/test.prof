	# gawk profile, created Wed Feb 14 11:21:16 2024

	# BEGIN rule(s)

	BEGIN {
     1  	OFS = "\t"
     1  	help = "     This script takes a grouping file and a decompressed VCF as input.\n     It outputs pi within each group and dxy between each pair of groups.\n     \n     Usage: \n     zcat file.vcf.gz | piawka [OPTIONS] groups_file - \n     \n     Options: \n     PIXY=1       calculate pixy-like pi instead of average weighted pi (default)\n     DXY=1        count between-group Dxy in addition to within-group pi (default)\n     MULT=1       use multiallelic sites\n     PERSITE=1    output values for each site instead of summary values\n     LOCUS='text' custom name of region to be shown in first column\n     HET=1        output heterozygosity, i.e. within-sample pi (unsets default DXY=1)\n     FST=XXX or 1 output Fst using one of the following estimators (sets DXY=1):\n                  HUD (default) : Hudson (1992) after Bhatia et al. (2013, eq. 10)\n     \n     Example groups.tsv:\n     \n     sample1 grp1\n     sample2 grp1\n     sample3 grp2\n     sample4 grp3\n     \n     Samples missing from the VCF or groups file will be silently skipped.\n     If one sample is assigned to two groups, only one will be used.\n     \n     Output is the long-format table with seven columns (no header):\n     \n     locus_name, nSites, pop1, pop2, nUsed, metric, value\n     \n     where nSites = SNPs + invariant sites,\n           nUsed = nSites - sites with too many alleles or too much missing data\n     \n     Version: 0.7"
     1  	if (! ARGV[1]) {
			print help
			exit 
		}
	}

	# Rule(s)

520450  NR == FNR { # 584
   584  	if (! HET) { # 584
   584  		groupmem[$1] = $2
		} else {
			groupmem[$1] = $1
		}
	}

520450  NR > FNR && /^#CHROM/ { # 1
     1  	if (PIXY == "") {
			PIXY = 1
		}
     1  	if (! HET && DXY == "") { # 1
     1  		DXY = 1
		}
     1  	if (FST) {
			DXY = 1
		}
    37  	for (i = 10; i <= NF; i++) {
    37  		if (groupmem[$i]) { # 37
    37  			groupindex[i] = groupmem[$i]
    37  			groups[groupmem[$i]]++
			}
		}
     1  	if (DXY && ! PERSITE) { # 1
     4  		for (g in groups) {
    16  			for (g2 in groups) {
    16  				if (g2 < g) { # 6
     6  					combs[g, g2]++
					}
				}
			}
		}
	}

520450  NR > FNR && /^[^#]/ { # 518807
518807  	if (! LOCUS) { # 518807
518807  		if (! minpos) { # 1
     1  			chrom = $1
     1  			minpos = $2
			}
518807  		if ($2 > maxpos) { # 500000
500000  			maxpos = $2
			}
		}
518807  	if ($4 ~ /^[ACGT]$/ && $5 !~ /\*|[ACGT]{2}/) { # 289790
289790  		L++
1159160  		for (g in groups) {
1159160  			miss[g] = 0
1159160  			nalleles[g] = 0
1159160  			nseen[g] = 0
			}
289790  		delete alleles
289790  		delete seen
10722230  		for (i = 10; i <= NF; i++) {
10722230  			grp = groupindex[i]
21076710  			for (c = 1; c < match($i, ":"); c += 2) {
21076710  				al = substr($i, c, 1)
21076710  				if (al == ".") { # 3231684
3231684  					if (! PIXY) { # 3231684
3231684  						miss[grp] += match($i, ":") / 2
						}
3231684  					break
17845026  				} else {
17845026  					if (HET) {
							thisal[al]++
						}
17845026  					alleles[grp, al]++
17845026  					nalleles[grp]++
17845026  					if (! seen[grp, al]) { # 928872
928872  						seen[grp, al]++
928872  						seen[grp] = al SUBSEP seen[grp]
928872  						nseen[grp]++
						}
					}
				}
10722230  			if (HET && nalleles[grp]) {
					Lal[grp]++
					if (MULT || nseen[grp] < 3) {
						if (! PERSITE && PIXY) {
							for (x in thisal) {
								numerator[grp] += thisal[x] * (nalleles[grp] - thisal[x])
							}
							denominator[grp] += nalleles[grp] * (nalleles[grp] - 1)
						} else {
							for (x in thisal) {
								pi[grp] += thisal[x] * (nalleles[grp] - thisal[x]) / (nalleles[grp] * (nalleles[grp] - 1))
							}
						}
					}
					if (PERSITE) {
						print $1 "_" $2, 1, g, ".", 1, "het", pi[g]
					}
					delete thisal
				}
			}
289790  		if (! HET) { # 289790
1159160  			for (g in groups) {
1159160  				if (miss[g] < nalleles[g] && (MULT || nseen[g] <= 2)) { # 813424
813424  					Lal[g]++
813424  					delete thesealleles
813424  					delete bothalleles
813424  					split(seen[g], xx, SUBSEP)
1652307  					for (al in xx) {
1652307  						bothalleles[xx[al]]++
1652307  						thesealleles[xx[al]] = alleles[g, xx[al]]
						}
813424  					thisnum[g] = nalleles[g] ^ 2
813424  					thisden[g] = nalleles[g] * (nalleles[g] - 1)
1652307  					for (x in thesealleles) {
1652307  						thisnum[g] -= thesealleles[x] ^ 2
						}
813424  					if (PERSITE) {
							print $1 "_" $2, 1, g, ".", 1, "pi", thisnum[g] / thisden[g]
813424  					} else if (PIXY) {
							numerator[g] += thisnum[g]
							denominator[g] += thisden[g]
813424  					} else {
813424  						pi[g] += thisnum[g] / thisden[g]
						}
813424  					if (DXY) { # 813424
3253696  						for (g2 in groups) {
3253696  							if (g2 < g && miss[g2] < nalleles[g2] && (MULT || nseen[g2] <= 2)) { # 1167554
1167554  								mutually_biallelic = 1
1167554  								delete thosealleles
1167554  								split(seen[g2], yy, SUBSEP)
2371273  								for (al in yy) {
2371273  									bothalleles[yy[al]]++
2371273  									thosealleles[yy[al]] = alleles[g2, yy[al]]
2371273  									if (! thesealleles[yy[al]] && nseen[g] == 2) { # 36840
 36840  										mutually_biallelic = 0
										}
									}
1167554  								if (MULT || mutually_biallelic) { # 1131157
1131157  									Lal[g, g2]++
1131157  									thisnum[g, g2] = nalleles[g] * nalleles[g2]
1131157  									thisden[g, g2] = thisnum[g, g2]
2298776  									for (x in bothalleles) {
2298776  										if (thesealleles[x] || thosealleles[x]) { # 1153984
1153984  											thisnum[g, g2] -= thesealleles[x] * thosealleles[x]
1153984  											if (FST == "HUD") {
													h_hat1 = thesealleles[x] * (nalleles[g] - thesealleles[x]) / (nalleles[g] * (nalleles[g] - 1))
													h_hat2 = thosealleles[x] * (nalleles[g2] - thosealleles[x]) / (nalleles[g2] * (nalleles[g2] - 1))
													fnum = (thesealleles[x] / nalleles[g] - thosealleles[x] / nalleles[g2]) ^ 2 - h_hat1 / nalleles[g] - h_hat2 / nalleles[g2]
													thisfstnum[g, g2] = fnum
													thisfstden[g, g2] = fnum + h_hat1 + h_hat2
												}
											}
										}
1131157  									if (PERSITE) {
											print $1 "_" $2, 1, g, g2, 1, "dxy", thisnum[g, g2] / thisden[g, g2]
											if (FST) {
												print $1 "_" $2, 1, g, g2, 1, "Fst_" FST, thisfstnum[g, g2] / thisfstden[g, g2]
											}
1131157  									} else {
1131157  										if (PIXY) {
												numerator[g, g2] += thisnum[g, g2]
												denominator[g, g2] += thisden[g, g2]
1131157  										} else {
1131157  											dxy[g, g2] += thisnum[g, g2] / thisden[g, g2]
											}
1131157  										if (FST) {
												fst_numerator[g, g2] += thisfstnum[g, g2]
												fst_denominator[g, g2] += thisfstden[g, g2]
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	# END rule(s)

	END {
     1  	if (! PERSITE) { # 1
     1  		if (PIXY) {
				pimetric = "pi_pixy"
				dxymetric = "dxy_pixy"
     1  		} else {
     1  			pimetric = "pi_w"
     1  			dxymetric = "dxy_w"
			}
     1  		if (HET) {
				pimetric = "het" substr(pimetric, match(pimetric, "_"))
			}
     1  		if (! LOCUS) { # 1
     1  			LOCUS = chrom "_" minpos "_" maxpos
			}
     4  		for (g in groups) {
     4  			if (Lal[g]) { # 4
     4  				if (PIXY) {
						piresult[g] = numerator[g] / denominator[g]
     4  				} else {
     4  					piresult[g] = pi[g] / Lal[g]
					}
     4  				print LOCUS, L, g, ".", Lal[g], pimetric, piresult[g]
				}
			}
     6  		for (i in combs) {
     6  			if (Lal[i]) { # 6
     6  				if (PIXY) {
						dxyresult[i] = numerator[i] / denominator[i]
     6  				} else {
     6  					dxyresult[i] = dxy[i] / Lal[i]
					}
     6  				split(i, ii, SUBSEP)
     6  				print LOCUS, L, ii[1], ii[2], Lal[i], dxymetric, dxyresult[i]
     6  				if (fst_denominator[i]) {
						print LOCUS, L, ii[1], ii[2], Lal[i], "Fst_" FST, fst_numerator[i] / fst_denominator[i]
					}
				}
			}
		}
	}

