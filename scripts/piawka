#!/usr/bin/mawk -f

BEGIN{ 
OFS="\t" 
help=" \
    This script takes a grouping file and a decompressed VCF as input.\n \
    It outputs pi within each group and dxy between each pair of groups.\n \
    \n \
    Usage: \n \
    zcat file.vcf.gz | piawka [OPTIONS] groups_file - \n \
    \n \
    Options: \n \
    PIXY=1       calculate pixy-like pi instead of average weighted pi (default)\n \
    DXY=1        count between-group Dxy in addition to within-group pi (default)\n \
    MULT=1       use multiallelic sites\n \
    PERSITE=1    output values for each site instead of summary values\n \
    LOCUS='text' custom name of region to be shown in first column\n \
    HET=1        output heterozygosity, i.e. within-sample pi (unsets default DXY=1)\n \
    FST=XXX or 1 output Fst using one of the following estimators (sets DXY=1):\n \
                 HUD (default) : Hudson (1992) after Bhatia et al. (2013, eq. 10)\n \
    \n \
    Example groups.tsv:\n \
    \n \
    sample1 grp1\n \
    sample2 grp1\n \
    sample3 grp2\n \
    sample4 grp3\n \
    \n \
    Samples missing from the VCF or groups file will be silently skipped.\n \
    If one sample is assigned to two groups, only one will be used.\n \
    \n \
    Output is the long-format table with seven columns (no header):\n \
    \n \
    locus_name, nSites, pop1, pop2, nUsed, metric, value\n \
    \n \
    where nSites = SNPs + invariant sites,\n \
          nUsed = nSites - sites with too many alleles or too much missing data\n \
    \n \
    Version: 0.7.1"
if ( !ARGV[1] ) { print help; exit }
}

# First file: store lists of group members in `groups` array
NR==FNR { 
  if ( !HET ) {
    groupmem[$1]=$2
  } else {
    groupmem[$1]=$1
  }
}

# Second file (VCF), header line
NR>FNR && /^#CHROM/ {

  # Set default variable values
  if ( PIXY == "" ) { PIXY=1 }
  if ( !HET && DXY == "" ) { DXY=1 }
  if ( FST ) { DXY=1 }

  # Assign sample positions to groups
  for (i=10; i<=NF; i++) {
    if ( groupmem[$i] ) { 
       groupindex[i]=groupmem[$i]
       groups[groupmem[$i]]++
     }
  }
  # Store group combinations
  if ( DXY && !PERSITE ) {
    for (g in groups) {
      for (g2 in groups) {
        if (g2 < g) { combs[g,g2]++ }
      }
    }
  }
}

# Second file: process sites
NR>FNR && /^[^#]/ {

  # Inferring range for locus name
  if ( !LOCUS ) {
    if ( !minpos ) { chrom=$1; minpos=$2 }
    if ( $2 > maxpos ) { maxpos=$2 }
  }

	# Process only SNPs (possibly monomorphic or multiallelic)
  # To obtain results identical to ksamuk/pixy, set $5 !~ /\*|,|[ACGT]{2}/
  # To process SNPs that only have one ALT allele
	if ( $4 ~ /^[ACGT]$/ && $5 !~ /\*|[ACGT]{2}/ ) {
  
    # Increment gene length for estimation of % missing
    L++

		# Reset site-specific parameters
		for (g in groups) { miss[g]=0; nalleles[g]=0; nseen[g]=0 }
		delete alleles
    delete seen

		# Pool GT values for groups, count each state and missing data
		for (i=10; i<=NF; i++) {
      grp=groupindex[i]
			for (c=1; c<match( $i, ":" ); c+=2) {
        al=substr($i,c,1)
				if ( al == "." ) {
					if ( !PIXY ) { miss[grp]+=match( $i, ":" )/2 }
          break
        } else {
          if ( HET ) { thisal[al]++ }
					alleles[grp,al]++
					nalleles[grp]++
          if ( !seen[grp,al] ) {
            seen[grp,al]++
            seen[grp]=al seen[grp]
            nseen[grp]++
          }
        }
			}
      if ( HET && nalleles[grp] ) {
        Lal[grp]++
        if ( MULT || nseen[grp]<=2 ) {
          if ( !PERSITE && PIXY ) { 
            for ( x in thisal ) { numerator[grp]+=thisal[x]*(nalleles[grp]-thisal[x]) }
            denominator[grp]+=nalleles[grp]*(nalleles[grp]-1)
          } else {
              for ( x in thisal ) { pi[grp]+=(thisal[x]*(nalleles[grp]-thisal[x])) / (nalleles[grp]*(nalleles[grp]-1)) }
          }
        }
        if ( PERSITE ) { print $1"_"$2, 1, g, ".", 1, "het", pi[g] }
        delete thisal
      }
		}

		# Calculate pi for groups with <50% missing data 
    # (if PIXY, use all sites with at least one genotype since miss[g]==0 )
    if ( !HET ) {
  		for ( g in groups ) {
  			if ( miss[g] < nalleles[g] && ( MULT || nseen[g]<=2 ) ) {
  
  				# Increment number of sites used for calculation
  				Lal[g]++
  
          # Extract allele counts of the group
          delete thesealleles
          delete bothalleles
          split(seen[g], xx, "")
          for (al in xx) {
            bothalleles[xx[al]]++
            thesealleles[xx[al]] = alleles[g,xx[al]]
          }
  
  				# Add to pi: probability that two randomly picked alleles differ
          # New formula below from https://pubmed.ncbi.nlm.nih.gov/36031871/
          thisnum[g]=nalleles[g]^2
          thisden[g]=nalleles[g]*(nalleles[g]-1)
          for ( x in thesealleles ) { thisnum[g]-=thesealleles[x]^2 }
          if ( PERSITE ) { print $1"_"$2, 1, g, ".", 1, "pi", thisnum[g]/thisden[g] 
          } else {
              if ( PIXY ) { numerator[g]+=thisnum[g]; denominator[g]+=thisden[g] 
              } else { pi[g]+=thisnum[g]/thisden[g] }
            }
  
  				# Calculate pi between this group and all other groups with <50% missing data
          if ( DXY ) {
  			  	for ( g2 in groups ) {
  			  		if ( g2 < g && miss[g2] < nalleles[g2] && ( MULT || nseen[g2]<=2 ) ) {
              
                # Is the union of allelic states from g1 and g2 bigger than nseen[g1]?
                poolsize=nseen[g]

                # Extract alleles of the group
                delete thosealleles
                split(seen[g2], yy, "")
                for (al in yy) {
                  bothalleles[yy[al]]++
                  thosealleles[yy[al]] = alleles[g2,yy[al]]
                  if ( !thesealleles[yy[al]] ) { poolsize++ }
                }

                # If not MULT, proceed only if common allele pool has <=2 alleles
                if ( MULT || poolsize <= 2 ) {

  			  	    	# Increment number of sites used for dxy
  			  	    	Lal[g,g2]++
                  
  			  	    	# Add to dxy: probability that two alleles picked from two groups differ
                  # subtraction rather than addition inspired by https://pubmed.ncbi.nlm.nih.gov/36031871/
                  thisnum[g,g2]=nalleles[g]*nalleles[g2]
                  thisden[g,g2]=thisnum[g,g2]
                  for ( x in bothalleles ) { 
                    if ( thesealleles[x] || thosealleles[x] ) {
                      thisnum[g,g2]-=thesealleles[x]*thosealleles[x]
                      if ( FST=="HUD" ) {
                        h_hat1 = (thesealleles[x]*(nalleles[g]-thesealleles[x])) /  (nalleles[g] *(nalleles[g] -1)) # maybe optimize later
                        h_hat2 = (thosealleles[x]*(nalleles[g2]-thosealleles[x])) / (nalleles[g2]*(nalleles[g2]-1)) # maybe optimize later
                        fnum=(thesealleles[x]/nalleles[g] - thosealleles[x]/nalleles[g2])^2 - h_hat1/nalleles[g] - h_hat2/nalleles[g2]
                        thisfstnum[g,g2]=fnum
                        thisfstden[g,g2]=fnum + h_hat1 + h_hat2
                      }
                      #if ( FST=="NEI" ) { # output does not look sensible so far
                      #  pi1 = 1 - (thesealleles[x]*(thesealleles[x]-1)) / (nalleles[g]* (nalleles[g]-1))
                      #  pi2 = 1 - (thosealleles[x]*(thosealleles[x]-1)) / (nalleles[g2]* (nalleles[g2]-1))
                      #  hw = ( pi1 + pi2 ) / 2
                      #  hb = 1 - (thesealleles[x]*thosealleles[x]) / (nalleles[g]*nalleles[g2])
                      #  thisfstnum[g,g2]=hb-hw
                      #  thisfstden[g,g2]=hb
                      #}
                    }
                  }
                  if ( PERSITE ) { 
                    print $1"_"$2, 1, g, g2, 1, "dxy", thisnum[g,g2]/thisden[g,g2]
                    if ( FST ) { print $1"_"$2, 1, g, g2, 1, "Fst_"FST, thisfstnum[g,g2]/thisfstden[g,g2] }
                  } else {
                      if ( PIXY ) { numerator[g,g2]+=thisnum[g,g2]; denominator[g,g2]+=thisden[g,g2] 
                      } else { dxy[g,g2]+=thisnum[g,g2]/thisden[g,g2] }
                      if ( FST ) { fst_numerator[g,g2]+=thisfstnum[g,g2]; fst_denominator[g,g2]+=thisfstden[g,g2] }
                    }
  			  	   	}
              }
  			  	}
          }
  			}
  		}
    }
	}
}

END {
  if ( !PERSITE ) {
    
    # Prepare "metric" field for output
    if ( PIXY ) { 
      pimetric="pi_pixy"
      dxymetric="dxy_pixy"
    } else { 
      pimetric="pi_w"
      dxymetric="dxy_w"
    }
    if ( HET ) {
      pimetric= "het" substr(pimetric, match(pimetric, "_") )
    }

    if ( !LOCUS ) { LOCUS=chrom"_"minpos"_"maxpos }

  	for (g in groups) {
      if ( Lal[g] ) {
        if ( PIXY ) { piresult[g] = numerator[g]/denominator[g]
        } else { piresult[g] = pi[g]/Lal[g] }
        print LOCUS, L, g, ".", Lal[g], pimetric, piresult[g]
      }
    }
  	for (i in combs) {
      if ( Lal[i] ) { 
        if ( PIXY ) { dxyresult[i] = numerator[i]/denominator[i]
        } else { dxyresult[i] = dxy[i]/Lal[i] }
        split(i, ii, SUBSEP)
        print LOCUS, L, ii[1], ii[2], Lal[i], dxymetric, dxyresult[i]
        if ( fst_denominator[i] ) { 
          print LOCUS, L, ii[1], ii[2], Lal[i], "Fst_"FST, fst_numerator[i]/fst_denominator[i] 
        }
      }
    }
  }
}

