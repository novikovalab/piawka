#!/usr/bin/mawk -f

# This script takes a grouping file (two columns: sample id and group) and a VCF as input.
# It outputs two kinds of diversity metrics: pi within each group and dxy between each pair of groups.

# Usage: piawka.mawk [OPTIONS] groups.tsv <( zcat file.vcf.gz )

# Options:
#
# MULT=1 : counts pi and dxy including multiallelic sites. Default is biallelic sites only. 
#       Higher values, lower comparability with other tools, but more honest and insightful.
#
# PERSITE=1 : returns per-site estimates instead of default VCF-wide average. Incompatible with PIXY.
#
# LOCUS="locus_name" : the name of the locus in the output. Meaningless with PERSITE. 
#         Default is "chr_start_end" (first chromosome encountered in the file is taken).
#
# PIXY=1 : use the missingness-based site weighting as in ksamuk/pixy.
#             Might be better for groups with lots (>10%) of missing data.
#             Our result might be different (and more precise) 
#             because here we also make use of sites marked as multiallelic
#             if they have two alleles in a given group.

# Example groups.tsv (any whitespace sep character recognizable as FS by awk should work):
#
# sample1 grp1
# sample2 grp1
# sample3 grp2
# sample4 grp3
# . . .
#
# It will silently skip samples missing from the VCF or groups file.
# If one sample is assigned to two groups, the last will be used.

# Output is the long-format table with seven columns (no header):
# locus_name, nSites, pop1, pop2, nUsed (passed missingness & n_alleles filters), metric (pi/dxy), value

# Version: 0.2 : included multiallelics with 2 alleles in given group into comparisons with !MULT,
#                switched to float-based pi and dxy formulas,
#                shortened PERSITE printing block,
#                dropped regex match in #CHROM block
#          0.3 : curly braces, curly braces everywhere
#          0.4 : add PIXY option

# Declare delimiters
BEGIN{ OFS="\t" }

# First file: store lists of group members in `groups` array
NR==FNR {groups[$2]++; groupmem[$2,$1]++}

# Second file: assign sample positions to groups
NR>FNR && /^#CHROM/ {
       for (i=10; i<=NF; i++) {
	       for (g in groups) {
		       if ( groupmem[g,$i] ) { groupindex[i]=g }
	       }
       }
  # Store group combinations
  if ( !PERSITE ) {
   for (g in groups) {
     for (g2 in groups) {
       if (g2 < g) { combs[g,g2]++ }
       }
     }
   }
}

# Second file: process sites
NR>FNR && /^[^#]/ {

  # Inferring range for locus name
  if ( !LOCUS ) {
    if ( !minpos ) { chrom=$1; minpos=$2 }
    if ( $2 > maxpos ) { maxpos=$2 }
  }

	# Process only SNPs (possibly monomorphic or multiallelic)
  # To obtain results identical to ksamuk/pixy, set $5 !~ /\*|,|[ACGT]{2}/
  # To process SNPs that only have one ALT allele
	if ( $4 ~ /^[ACGT]$/ && $5 !~ /\*|[ACGT]{2}/ ) {
  
    # Increment gene length for estimation of % missing
    L++

		# Extract GT fields from samples data
		gsub(/:[^\t]*/, "", $0)

		# Reset site-specific parameters
		for (g in groups) { miss[g]=0; nalleles[g]=0; nseen[g]=0 }
		delete alleles
    delete seen

		# Pool alleles for groups, count each allele and missing data
		for (i=10; i<=NF; i++) {
			split($i, chars, /\||\//)
			for (al in chars) {
				if ( chars[al] == "." ) {
					if ( !PIXY ) { miss[groupindex[i]]++ }
        } else {
					alleles[groupindex[i],chars[al]]++
					nalleles[groupindex[i]]++
          if ( !seen[groupindex[i],chars[al]] ) {
            seen[groupindex[i],chars[al]]++
            nseen[groupindex[i]]++
          }
        }
			}
		}

		# Calculate pi for groups with <50% missing data 
    # (if PIXY, use all sites with at least one genotype since miss[g]==0 )
		for ( g in groups ) {
			if ( miss[g] < nalleles[g] && ( MULT || nseen[g]<3 ) ) {

				# Increment number of sites used for calculation
				Lal[g]++

        # Extract allele counts of the group
        delete thesealleles
        for (ij in alleles) {
          if ( ij ~ "^" g SUBSEP ) {
            thesealleles[ij] = alleles[ij]
          }
        }

				# Add to pi: probability that two randomly picked alleles differ
				if ( PIXY ) {
          for ( x in thesealleles ) { numerator[g]+=thesealleles[x]*(nalleles[g]-thesealleles[x]) }
          denominator[g]+=(nalleles[g]*(nalleles[g]-1))
        } else {
          for ( x in thesealleles ) { pi[g]+=(thesealleles[x]*(nalleles[g]-thesealleles[x])) / (nalleles[g]*(nalleles[g]-1)) }
        # New formula for non-PIXY approach below from https://pubmed.ncbi.nlm.nih.gov/36031871/ (not much of a speed-up though)
        #thispi[g]=nalleles[g]^2
        #for ( x in thesealleles ) { thispi[g]-=thesealleles[x]^2 }
        #pi[g]+=thispi[g]/(nalleles[g]*(nalleles[g]-1))
        }
        
        if ( PERSITE ) { print $1"_"$2, 1, g, ".", 1, "pi", pi[g] }

				# Calculate pi between this group and all other groups with <50% missing data
				for ( g2 in groups ) {
					if ( g2 < g && miss[g2] < nalleles[g2] && ( MULT || nseen[g2]<3 ) ) {
          
						# Increment number of sites used for dxy
						Lal[g,g2]++

          # Extract alleles of the group
          delete thosealleles
          for (ij in alleles) {
           if ( ij ~ "^" g2 SUBSEP ) {
             thosealleles[ij] = alleles[ij]
           }
          }
						# Add to dxy: probability that two alleles picked from two groups differ
            # new formula ( three expressions with thisdxy[g,g2] )
            # inspired by https://pubmed.ncbi.nlm.nih.gov/36031871/ (also not really speeding things up)
            #thisdxy[g,g2]=nalleles[g]*nalleles[g2]
						for ( x in thesealleles ) {
              split(x, xx, SUBSEP)
              #thisdxy[g,g2]-=thesealleles[x]*thosealleles[g2,xx[2]]
							for ( y in thosealleles ) {
                split(y, yy, SUBSEP)
								if (xx[2] != yy[2]) { 
                  if ( PIXY ) { numerator[g,g2]+=thesealleles[x]*thosealleles[y] 
                  } else { dxy[g,g2]+=thesealleles[x]*thosealleles[y] / (nalleles[g]*nalleles[g2]) 
                  }
							  }
						  }
            #dxy[g,g2]+=thisdxy[g,g2]/(nalleles[g]*nalleles[g2])
            }
            denominator[g,g2]+=(nalleles[g]*nalleles[g2])
            if ( PERSITE ) { print $1"_"$2, 1, g, g2, 1, "dxy", dxy[g,g2] }
					}
				}
			}
		}
	}
}

END {
  if ( !PERSITE ) {
    
    if ( !LOCUS ) { LOCUS=chrom"_"minpos"_"maxpos }

    if ( PIXY ) { 
      pimetric="pi_pixy"
      dxymetric="dxy_pixy"
    } else { 
      pimetric="pi_w"
      dxymetric="dxy_w"
    }

  	for (g in groups) {
      if ( Lal[g] ) {
        if ( PIXY ) { piresult[g] = numerator[g]/denominator[g]
        } else { piresult[g] = pi[g]/Lal[g] }
        print LOCUS, L, g, ".", Lal[g], pimetric, piresult[g]
      }
    }
  	for (i in combs) {
      if ( Lal[i] ) { 
        if ( PIXY ) { dxyresult[i] = numerator[i]/denominator[i]
        } else { dxyresult[i] = dxy[i]/Lal[i] }
        split(i, ii, SUBSEP)
        print LOCUS, L, ii[1], ii[2], Lal[i], dxymetric, dxyresult[i]
      }
    }
  }
}

